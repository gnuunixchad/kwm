Author: nate zhou <gnuunixchad@outlook.com>
Date:   Sun Feb 1 16:36:18 2026 +0800


diff --git a/src/kwm/bar.zig b/src/kwm/bar.zig
index edd69d3..4b4862c 100644
--- a/src/kwm/bar.zig
+++ b/src/kwm/bar.zig
@@ -133,14 +133,45 @@ pub fn handle_click(self: *Self, seat: *Seat) void {
     }
 
     x -= self.static_component_width();
-    for (&[_]@TypeOf(config.bar.click).Key { .layout, .mode, .title }, self.dynamic_splits.items) |tag, split| {
-        if (x <= split) {
-            action = (config.bar.click.get(tag) orelse return).get(seat.button) orelse return;
+
+    const context = Context.get();
+
+    const dynamic_width: i32 = @intCast(self.output.width - self.static_component_width());
+
+    const status_text: []const u8 = switch (config.bar.status) {
+        .text => |text| text,
+        else => mem.span(@as([*:0]const u8, @ptrCast(&status_buffer))),
+    };
+    if (status_text.len > 0) {
+        const status_width = str_width(self.font, status_text) orelse 0;
+        const pad = self.get_pad();
+        const status_start = dynamic_width - @as(i32, @intCast(status_width)) - @as(i32, @intCast(pad));
+        if (x >= status_start) {
+            action = (config.bar.click.get(.status) orelse return).get(seat.button) orelse return;
             return;
         }
     }
 
-    action = (config.bar.click.get(.status) orelse return).get(seat.button) orelse return;
+    if (self.dynamic_splits.items.len > 0) {
+        if (x < self.dynamic_splits.items[0]) {
+            action = (config.bar.click.get(.layout) orelse return).get(seat.button) orelse return;
+            return;
+        }
+
+        if (self.dynamic_splits.items.len > 1) {
+            const mode_tag = if (config.mode_tag.contains(context.mode))
+                config.mode_tag.getAssertContains(context.mode)
+            else @tagName(context.mode);
+            if (mode_tag.len > 0) {
+                if (x < self.dynamic_splits.items[1]) {
+                    action = (config.bar.click.get(.mode) orelse return).get(seat.button) orelse return;
+                    return;
+                }
+            }
+        }
+    }
+
+    action = (config.bar.click.get(.title) orelse return).get(seat.button) orelse return;
 }
 
 
@@ -481,14 +512,42 @@ fn render_dynamic_component(self: *Self) void {
     var x: i16 = 0;
     const y: i16 = 0;
 
-    x += self.render_str(
-        buffer,
-        config.layout_tag(self.output.current_layout()),
-        &normal_fg,
-        x+@as(i16, @intCast(@divFloor(pad, 2))),
-        y,
-    ) + @as(i16, @intCast(pad));
-    self.dynamic_splits.appendBounded(x) catch unreachable;
+    const current_layout = self.output.current_layout();
+    if (current_layout == .monocle) {
+        var visible_count: usize = 0;
+        {
+            var it = context.windows.safeIterator(.forward);
+            while (it.next()) |window| {
+                if (window.is_visible_in(self.output) and !window.floating) {
+                    visible_count += 1;
+                }
+            }
+        }
+
+        const layout_symbol = if (visible_count == 0)
+            config.layout_tag(.monocle)
+        else blk: {
+            var buf: [16]u8 = undefined;
+            const formatted = std.fmt.bufPrint(&buf, "[{}]", .{visible_count}) catch "[?]";
+            break :blk formatted;
+        };
+
+        x += self.render_str(
+            buffer,
+            layout_symbol,
+            &normal_fg,
+            x+@as(i16, @intCast(@divFloor(pad, 2))),
+            y,
+        ) + @as(i16, @intCast(pad));
+    } else {
+        x += self.render_str(
+            buffer,
+            config.layout_tag(current_layout),
+            &normal_fg,
+            x+@as(i16, @intCast(@divFloor(pad, 2))),
+            y,
+        ) + @as(i16, @intCast(pad));
+    }
 
     const mode_tag =
         if (config.mode_tag.contains(context.mode)) config.mode_tag.getAssertContains(context.mode)
